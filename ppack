#!/bin/bash

set -e

function die
{
  echo "ppack: error: $@" >&2
}

# Process arguments.
dest=$(pwd)
directories=()
remove_archives=no
for arg; do
  case "$arg" in
    --help)
      echo "Usage: packdir [PATHS]..."
      echo "A tool for creating project snapshots."
      echo
      echo "This script will pack the given directories and append a"
      echo "timestamp to the archive name. The timestamp will be either"
      echo "the modification time of the newest file, or of the latest"
      echo "commit."
      echo
      echo "All arguments will be interpreted as absolute or relative"
      echo "paths. The only exception are the following arguments:"
      echo -e "      --dest=PATH\t\tThe directory in which the archive" \
        "should be"
      echo -e "\t\t\t\tcreated. Defaults to the current directory."
      echo -e "  -r, --remove-archives\t\tRemove previously existing" \
        "archives for each"
      echo -e "\t\t\t\tdirectory."
      echo -e "      --help\t\t\tPrint this help and exit."
      exit
      ;;
    --dest=*)
      new_dest=${arg#--dest=}
      dest=$(readlink -f "$new_dest" || true)
      test ! -d "$dest" && die "invalid path: \"$new_dest\""
      ;;
    -r|--remove-archives)
      remove_archives=yes
      ;;
    *)
      test -d "$arg" || die "invalid directory: \"$dir\""
      directories+=("$arg")
      ;;
  esac
done

test ${#directories[@]} == 0 && die "no directories specified"

# Define some color codes.
blue="$(tput bold)$(tput setf 1)"
green="$(tput bold)$(tput setf 2)"
red="$(tput bold)$(tput setf 4)"
magenta="$(tput bold)$(tput setf 5)"
yellow="$(tput bold)$(tput setf 6)"
reset=$(tput sgr0)

# Returns the timestamp of the latest file in the given directory. If no
# file could be found, it falls back to the directories timestamp.
#
# $1 A valid directory path.
function find_latest_timestamp
{
  timestamp=$(find "$1" -type f ! -path "*/.git/*" \
    ! -path "*/.svn/*" ! -path "*/.bzr/*" ! -path "*/.cvs/*" \
    -exec stat -c "%Y" {} ';' | sort -nr | head -n1)

  test -n "$timestamp" || timestamp=$(stat -c "%Y" "$1")
  date -d "@$timestamp" +"%d-%m-%y-%H:%M:%S"
}

for dir in "${directories[@]}"; do
  project_path=$(readlink -f "$dir")
  project_name=$(basename "$project_path")
  cd "$(dirname "$project_path")"
  exclude=()

  if [[ -d "$project_name/.git" ]]; then
    date_string=$(git -C "$project_name" show -s --format='%ci' HEAD 2>/dev/null |
    sed -E 's,^..([0-9]{2})-([0-9]{2})-([0-9]{2}) (\S+).*$,\3-\2-\1-\4,g' ||
      find_latest_timestamp "$project_name")

    # Extract and expand paths in .gitignore.
    test -f "$project_name/.gitignore" &&
      for file in $(sed -r "s,^(.*)$,$project_name/\1,g" "$project_name/.gitignore");
      do
        exclude+=("$(sed -r 's,^(.*[^/])/*$,--exclude=\1,g' <<< "$file")");
      done

    # Summarize git status.
    git_status=$(LANG=en git -C "$project_name" status 2>/dev/null)
    case "$git_status" in
      *Changes\ not\ staged\ for\ commit*)
        echo "${magenta}unstaged changes${reset}: $project_name";;
      *Changes\ to\ be\ committed*)
        echo "${yellow}uncommitted changes${reset}: $project_name";;
      *Your\ branch\ is\ ahead\ of\ \'origin/master\'\ by\ *\ commits*)
        echo "${green}ready to push${reset}: $project_name";;
      *untracked\ files*)
        echo "${red}untracked files${reset}: $project_name";;
    esac
  else
    echo
  fi

  archive_path="${dest}/${project_name}-${date_string}.tar.xz"
  if [[ ! -e "$archive_path" ]]; then
    [[ "$remove_archives" == "yes" ]] &&
      { rm -v "$dest/$project_name"-??-??-??-??:??:??.tar.xz 2>/dev/null ||
        true; }

    tar -c --xz -f "$archive_path" "$project_name" "${exclude[@]}" &&
      echo "${blue}packed${reset} $project_name"
  fi
done
