#!/bin/bash

set -e

# Process arguments.
dest=$(pwd)
directories=()
remove_archives=no
for arg; do
  case "$arg" in
    --help)
      echo "Usage: packdir [PATHS]..."
      echo "A small tool for creating directory snapshots."
      echo
      echo "This script will pack the given directories and append a"
      echo "timestamp to the archive name. The timestamp will be either"
      echo "the modification time of the newest file, or of the latest"
      echo "commit."
      echo
      echo "All arguments will be interpreted as absolute or relative"
      echo "paths. The only exception are the following arguments:"
      echo -e "      --dest=PATH\t\tThe directory in which the archive" \
        "should be"
      echo -e "\t\t\t\tcreated. Defaults to the current directory."
      echo -e "  -r, --remove-archives\t\tRemove previously existing" \
        "archives for each"
      echo -e "\t\t\t\tdirectory."
      echo -e "      --help\t\t\tPrint this help and exit."
      exit
      ;;
    --dest=*)
      new_dest=${arg#--dest=}
      dest=$(readlink -f "$new_dest" || true)
      test ! -d "$dest" &&
        echo "packdir: error: invalid path: \"$new_dest\"" >&2 &&
        exit 1
      ;;
    -r|--remove-archives)
      remove_archives=yes
      ;;
    *)
      directories+=("$arg")
      ;;
  esac
done

test ${#directories[@]} == 0 &&
  echo "packdir: no directories specified" >&2 &&
  exit

# Define some color codes.
blue="$(tput bold)$(tput setf 1)"
green="$(tput bold)$(tput setf 2)"
red="$(tput bold)$(tput setf 4)"
magenta="$(tput bold)$(tput setf 5)"
yellow="$(tput bold)$(tput setf 6)"
reset=$(tput sgr0)

# Checks whether the given git repo can be packed and returns 1 otherwise.
# Must be executed in the parent directory of the project.
#
# $1 The project name of the given repository.
function check_git_repo
{
  ! command -v git >&/dev/null &&
    echo "${yellow}skipped${reset}: git is not installed: \"$1\"" &&
    return 1

  ! git -C "$1" show -s HEAD >&/dev/null &&
    echo "${yellow}skipped${reset}: no commits: \"$1\"" &&
    return 1

  # Summarize git status.
  git_status=$(LANG=en git -C "$1" status)
  case "$git_status" in
    *Changes\ not\ staged\ for\ commit*)
      echo "${magenta}unstaged changes${reset}: $1";;
    *Changes\ to\ be\ committed*)
      echo "${yellow}uncommitted changes${reset}: $1";;
    *Your\ branch\ is\ ahead\ of\ \'origin/master\'\ by\ *\ commits*)
      echo "${green}ready to push${reset}: $1";;
    *untracked\ files*)
      echo "${red}untracked files${reset}: $1";;
  esac
}

for dir in "${directories[@]}"; do
  test ! -d "$dir/" && \
    echo "${red}ignore${reset}: invalid directory: \"$dir\"" && \
    continue

  # Setup environment and try to extract timestamps from git repositories.
  project_path=$(readlink -f "$dir")
  project_name=$(basename "$project_path")
  cd "$(dirname "$project_path")"
  exclude=()

  if [[ -d "$project_name/.git" ]]; then
    check_git_repo "$project_name" || continue
    date_string=$(git -C "$project_name" show -s --format='%ci' HEAD 2>/dev/null |
      sed -E 's,^..([0-9]{2})-([0-9]{2})-([0-9]{2}) (\S+).*$,\3-\2-\1-\4,g')

    # Extract and expand paths in .gitignore.
    test -f "$project_name/.gitignore" &&
      for file in $(sed -r "s,^(.*)$,$project_name/\1,g" "$project_name/.gitignore");
      do
        exclude+=("$(sed -r 's,^(.*[^/])/*$,--exclude=\1,g' <<< "$file")");
      done
  else
    date_string=$(find "$project_name" -mindepth 1 -exec stat -c "%Y" {} ';' |
      sort -nr | head -n1)

    test -z "$date_string" &&
      echo "${yellow}skipped${reset}: empty directory: \"$dir\"" &&
      continue

    date_string=$(date -d "@$date_string" +"%d-%m-%y-%H:%M:%S")
  fi

  archive_path="${dest}/${project_name}-${date_string}.tar.xz"
  if [[ ! -e "$archive_path" ]]; then
    [[ "$remove_archives" == "yes" ]] &&
      { rm -v "$dest/$project_name"-??-??-??-??:??:??.tar.xz 2>/dev/null ||
        true; }

    tar -c --xz -f "$archive_path" "$project_name" "${exclude[@]}" &&
      echo "${blue}packed${reset} $project_name"
  fi
done
